import json
from pathlib import Path
import sys
import subprocess
import time
from typing import Optional

import psutil

from .constants import DEFAULT_META_DIR, META_SUFFIX
from .types import DmonCommandConfig, DmonMeta, PathType


def ensure_meta_dir(meta_path: Path):
    """
    Ensure the meta directory exists.
    If it is under the default meta directory, create .gitignore to ignore all files in it.
    """
    meta_dir = meta_path.resolve().parent
    meta_dir.mkdir(parents=True, exist_ok=True)
    if meta_dir == DEFAULT_META_DIR.resolve():
        gitignore = DEFAULT_META_DIR / ".gitignore"
        if not gitignore.exists():
            gitignore.write_text("# Auto-generated by dmon\n*\n")


def ensure_log_dir(log_path: Path):
    log_path.parent.mkdir(parents=True, exist_ok=True)


def load_meta(meta_path: Path) -> Optional[DmonMeta]:
    if meta_path.exists():
        meta: DmonMeta = json.loads(meta_path.read_text())
        return meta
    return None


def dump_meta(meta: DmonMeta, meta_path: Path):
    meta_path.write_text(json.dumps(meta, indent=2, ensure_ascii=False))


def start(cfg: DmonCommandConfig):
    meta_path = Path(cfg["meta_path"]).resolve()
    log_path = Path(cfg["log_path"]).resolve()
    if meta_path.exists():
        print(f"Meta file already exists: {meta_path} (maybe still running?)")
        print("Run 'dmon status' to check or 'dmon stop' to stop it.")
        return 1

    ensure_meta_dir(meta_path)
    ensure_log_dir(log_path)

    # Parameters to run the process in background detached from parent
    kwargs = {}
    if isinstance(cfg["cmd"], str):
        kwargs["shell"] = True
    if sys.platform.startswith("win"):
        DETACHED_PROCESS = 0x00000008
        kwargs["creationflags"] = DETACHED_PROCESS
    else:
        # Make the child process independent of the parent process in Unix-like systems
        kwargs["start_new_session"] = True

    # Open the log file (append mode)
    with open(log_path, "a") as lof:
        # Start the child process with stdout/stderr redirected to the log
        proc = subprocess.Popen(cfg["cmd"], stdout=lof, stderr=lof, env=cfg["env"], **kwargs)
        start_time = time.time()
        start_time_human = time.strftime(
            "%Y-%m-%d %H:%M:%S", time.localtime(start_time)
        )

    dump_meta(
        {
            "pid": proc.pid,
            "meta_path": str(meta_path),
            "log_path": str(log_path),
            "cmd": cfg["cmd"],
            "env": cfg["env"],
            "popen_kwargs": kwargs,
            "start_time": start_time,
            "start_time_human": start_time_human,
        },
        meta_path,
    )

    print(
        f"PID: {proc.pid}\n"
        f"START TIME: {start_time_human}\n"
        f"META PATH: {meta_path}\n"
        f"LOG PATH: {log_path}"
    )
    return 0


def stop(
    meta_path: PathType,
    timeout=5.0,
):
    meta_path = Path(meta_path).resolve()
    meta = load_meta(meta_path)
    if meta is None:
        print(f"Meta file not found: {meta_path} (maybe not started?)")
        return 1

    pid = meta["pid"]
    try:
        proc = psutil.Process(pid)
    except psutil.NoSuchProcess:
        print(f"Process {pid} not found (already dead)")
        meta_path.unlink(missing_ok=True)
        return 1

    # send SIGTERM first for graceful shutdown (if platform supports)
    proc.terminate()

    # wait for the process to exit or timeout
    try:
        ret = proc.wait(timeout)
        print(f"Process {pid} exited with code {ret}")
    except psutil.TimeoutExpired:
        print(f"Process {pid} did not exit in time with code; killing it")

        # first kill child processes
        for child in proc.children(recursive=True):
            try:
                child.kill()
            except Exception:
                pass
        # then kill the parent process
        try:
            proc.kill()
            print(f"Stopped process {pid}")
        except Exception as e:
            print(f"Failed to kill process {pid}: {e}")

    # remove the PID file
    try:
        # os.remove(pid_file)
        meta_path.unlink(missing_ok=True)
    except OSError:
        pass
    return 0


def restart(
    cfg: DmonCommandConfig,
    timeout=5.0,
):
    stop(cfg["meta_path"], timeout)
    return start(cfg)


def status(meta_path: PathType):
    meta_path = Path(meta_path).resolve()
    meta = load_meta(meta_path)
    if meta is None:
        print(f"Meta file not found: {meta_path} (maybe not started?)")
        return 1

    pid = meta["pid"]

    if psutil.pid_exists(pid):
        print(f"Process {pid} is running")
        return 0
    else:
        print(f"Process {pid} is NOT running")
        return 1


def list_processes(dir: PathType):
    headers = ("NAME", "PID", "CMD", "START TIME", "LOG PATH")
    metas = []
    target_dmon_dir = Path(dir).resolve()
    if target_dmon_dir.exists() and target_dmon_dir.is_dir():
        for meta_file in target_dmon_dir.glob(f"*{META_SUFFIX}"):
            name = meta_file.stem.rsplit(".", 2)[0]
            meta = load_meta(meta_file)
            if meta is not None:
                metas.append(
                    (
                        name,
                        meta["pid"],
                        meta["cmd"],
                        meta["start_time_human"],
                        meta["log_path"],
                    )
                )
    metas.sort()

    print(f"Found {len(metas)} running process(es) in {target_dmon_dir}:")

    # insert table header
    metas.insert(0, headers)

    # calculate column widths
    widths = [max(len(str(row[i])) for row in metas) for i in range(len(headers))]

    # print the table with proper padding
    for row in metas:
        line = "  ".join(f"{str(cell):<{widths[i]}}" for i, cell in enumerate(row))
        print(line)
    return 0
