import json
import os
from pathlib import Path
import sys
import subprocess
import time
from typing import Optional

import psutil

from .constants import DEFAULT_META_DIR, META_SUFFIX
from .types import DmonCommandConfig, DmonMeta, PathType


def ensure_meta_dir(meta_path: Path):
    """
    Ensure the meta directory exists.
    If it is under the default meta directory, create .gitignore to ignore all files in it.
    """
    meta_dir = meta_path.resolve().parent
    meta_dir.mkdir(parents=True, exist_ok=True)
    if meta_dir == DEFAULT_META_DIR.resolve():
        gitignore = DEFAULT_META_DIR / ".gitignore"
        if not gitignore.exists():
            gitignore.write_text("# Auto-generated by dmon\n*\n")


def ensure_log_dir(log_path: Path):
    log_path.parent.mkdir(parents=True, exist_ok=True)


def load_meta(meta_path: Path) -> Optional[DmonMeta]:
    if meta_path.exists():
        meta: DmonMeta = json.loads(meta_path.read_text())
        return meta
    return None


def dump_meta(meta: DmonMeta, meta_path: Path):
    meta_path.write_text(json.dumps(meta, indent=2, ensure_ascii=False))


def start(cfg: DmonCommandConfig):
    meta_path = Path(cfg["meta_path"]).resolve()
    log_path = Path(cfg["log_path"]).resolve()
    cwd = Path(cfg["cwd"]).resolve()

    try:
        ret_meta = load_meta(meta_path)
    except Exception:
        ret_meta = None
    if ret_meta:
        print(
            f"Meta file already exists (name: '{ret_meta['name']}'): {meta_path} (maybe still running?)\n"
            "Run 'dmon status' / 'dmon list' to check, or 'dmon stop' to stop it."
        )
        return 1

    ensure_meta_dir(meta_path)
    ensure_log_dir(log_path)

    # Parameters to run the process in background detached from parent
    kwargs = {}
    if isinstance(cfg["cmd"], str):
        kwargs["shell"] = True
    if sys.platform.startswith("win"):
        DETACHED_PROCESS = 0x00000008
        kwargs["creationflags"] = DETACHED_PROCESS
    else:
        # Make the child process independent of the parent process in Unix-like systems
        kwargs["start_new_session"] = True

    env = None  # default behavior of Popen
    if cfg["override_env"]:
        env = cfg["env"]
    elif cfg["cwd"]:
        env = {**os.environ, **cfg["env"]}

    # Open the log file (append mode)
    with open(log_path, "a") as lof:
        # Start the child process with stdout/stderr redirected to the log
        proc = subprocess.Popen(
            cfg["cmd"], stdout=lof, stderr=lof, cwd=cwd, env=env, **kwargs
        )
        try:
            p = psutil.Process(proc.pid)
            create_time = p.create_time()
            create_time_human = time.strftime(
                "%Y-%m-%d %H:%M:%S", time.localtime(create_time)
            )
        except psutil.NoSuchProcess:
            # process already exited?
            create_time = -1
            create_time_human = "N/A"

    meta: DmonMeta = {
        "name": cfg["name"],
        "pid": proc.pid,
        "meta_path": str(meta_path),
        "log_path": str(log_path),
        "cmd": cfg["cmd"],
        "cwd": str(cwd),
        "env": cfg["env"],
        "override_env": cfg["override_env"],
        "popen_kwargs": kwargs,
        "create_time": create_time,
        "create_time_human": create_time_human,
    }
    dump_meta(
        meta,
        meta_path,
    )

    print_status(meta)
    return 0


def stop(
    meta_path: PathType,
    timeout=5.0,
):
    meta_path = Path(meta_path).resolve()
    meta = load_meta(meta_path)
    if meta is None:
        print(f"Meta file not found: {meta_path} (maybe not started?)")
        return 1

    pid = meta["pid"]
    try:
        proc = psutil.Process(pid)
    except psutil.NoSuchProcess:
        print(f"Process {pid} not found (already dead)")
        meta_path.unlink(missing_ok=True)
        print_status(meta)
        return 1

    # send SIGTERM first for graceful shutdown (if platform supports)
    proc.terminate()

    # wait for the process to exit or timeout
    try:
        ret = proc.wait(timeout)
        print(f"Process {pid} exited with code {ret}")
    except psutil.TimeoutExpired:
        print(f"Process {pid} did not exit in time with code; killing it")

        # first kill child processes
        for child in proc.children(recursive=True):
            try:
                child.kill()
            except Exception:
                pass
        # then kill the parent process
        try:
            proc.kill()
            print(f"Stopped process {pid}")
        except Exception as e:
            print(f"Failed to kill process {pid}: {e}")

    # remove the PID file
    try:
        # os.remove(pid_file)
        meta_path.unlink(missing_ok=True)
    except OSError:
        pass

    print_status(meta)
    return 0


def restart(
    cfg: DmonCommandConfig,
    timeout=5.0,
):
    stop(cfg["meta_path"], timeout)
    print("--- Restarting ---")
    return start(cfg)


def status(meta_path: PathType):
    meta_path = Path(meta_path).resolve()
    meta = load_meta(meta_path)
    if meta is None:
        print(f"Meta file not found: {meta_path} (maybe not started?)")
        return 1

    print_status(meta)
    return 0


def check_running(pid: int, create_time: float) -> bool:
    """
    Check if a process with given PID and create_time is running.
    """
    # return psutil.pid_exists(pid)
    if create_time < 0:
        return False
    try:
        p = psutil.Process(pid)
        return abs(p.create_time() - create_time) < 1e-3
    except psutil.NoSuchProcess:
        return False


def print_status(meta: DmonMeta):
    pid = meta["pid"]
    status = "Running" if check_running(pid, meta["create_time"]) else "Exited"
    print(
        f"NAME: {meta['name']}\n"
        f"PID: {pid}\n"
        f"STATUS: {status}\n"
        f"CMD: {meta['cmd']}\n"
        f"WORKING DIR: {meta['cwd']}\n"
        f"CREATE TIME: {meta['create_time_human']}\n"
        f"LOG PATH: {meta['log_path']}\n"
        f"META PATH: {meta['meta_path']}"
    )


def list_processes(dir: PathType):
    headers = ("NAME", "PID", "STATUS", "CMD", "CREATE TIME", "LOG PATH")
    metas = []
    target_dmon_dir = Path(dir).resolve()
    if target_dmon_dir.exists() and target_dmon_dir.is_dir():
        for meta_file in target_dmon_dir.glob(f"*{META_SUFFIX}"):
            name = meta_file.stem.rsplit(".", 2)[0]
            meta = load_meta(meta_file)
            if meta is not None:
                metas.append(
                    (
                        name,
                        meta["pid"],
                        "Running"
                        if check_running(meta["pid"], meta["create_time"])
                        else "Exited",
                        meta["cmd"],
                        meta["create_time_human"],
                        meta["log_path"],
                    )
                )
    metas.sort()

    print(f"Found {len(metas)} process(es) in {target_dmon_dir}:")

    # insert table header
    metas.insert(0, headers)

    # calculate column widths
    widths = [max(len(str(row[i])) for row in metas) for i in range(len(headers))]

    # print the table with proper padding
    for row in metas:
        line = "  ".join(f"{str(cell):<{widths[i]}}" for i, cell in enumerate(row))
        print(line)
    return 0
