import json
import os
from pathlib import Path
import sys
import subprocess
import time
from typing import Optional

import psutil
from termcolor import colored

from .constants import ANSI_RE, DEFAULT_META_DIR, META_SUFFIX
from .types import DmonCommandConfig, DmonMeta, PathType


def ensure_meta_dir(meta_path: Path):
    """
    Ensure the meta directory exists.
    If it is under the default meta directory, create .gitignore to ignore all files in it.
    """
    meta_dir = meta_path.resolve().parent
    meta_dir.mkdir(parents=True, exist_ok=True)
    if meta_dir == DEFAULT_META_DIR.resolve():
        gitignore = DEFAULT_META_DIR / ".gitignore"
        if not gitignore.exists():
            gitignore.write_text("# Auto-generated by dmon\n*\n")


def ensure_log_dir(log_path: Path):
    log_path.parent.mkdir(parents=True, exist_ok=True)


def load_meta(meta_path: Path) -> Optional[DmonMeta]:
    if meta_path.exists():
        meta: DmonMeta = json.loads(meta_path.read_text())
        return meta
    return None


def dump_meta(meta: DmonMeta, meta_path: Path):
    meta_path.write_text(json.dumps(meta, indent=2, ensure_ascii=False))


def start(cfg: DmonCommandConfig):
    meta_path = Path(cfg["meta_path"]).resolve()
    log_path = Path(cfg["log_path"]).resolve()
    cwd = Path(cfg["cwd"]).resolve()

    try:
        ret_meta = load_meta(meta_path)
    except Exception:
        ret_meta = None
    if ret_meta:
        print(
            f"{colored('Start failed: meta file already exists', color='red', attrs=['bold'])}",
            file=sys.stderr,
        )
        print_status(ret_meta)
        print(
            "\nRun 'dmon status' / 'dmon list' to check, or 'dmon stop' to stop it.",
            file=sys.stderr,
        )
        return 1

    ensure_meta_dir(meta_path)
    ensure_log_dir(log_path)

    env = None  # default behavior of Popen
    if cfg["override_env"]:
        env = cfg["env"]
    elif cfg["cwd"]:
        env = {**os.environ, **cfg["env"]}

    shell = isinstance(cfg["cmd"], str)

    # Platform-specific parameters to run the process in background detached from parent
    kwargs = {}
    if sys.platform.startswith("win"):
        DETACHED_PROCESS = 0x00000008
        kwargs["creationflags"] = DETACHED_PROCESS
    else:
        # Make the child process independent of the parent process in Unix-like systems
        kwargs["start_new_session"] = True

    # Open the log file (append mode)
    with open(log_path, "a") as lof:
        # Start the child process with stdout/stderr redirected to the log
        proc = subprocess.Popen(
            cfg["cmd"], stdout=lof, stderr=lof, cwd=cwd, env=env, shell=shell, **kwargs
        )
        try:
            p = psutil.Process(proc.pid)
            create_time = p.create_time()
            create_time_human = time.strftime(
                "%Y-%m-%d %H:%M:%S", time.localtime(create_time)
            )
        except psutil.NoSuchProcess:
            # process already exited?
            create_time = -1
            create_time_human = "N/A"

    meta: DmonMeta = {
        "name": cfg["name"],
        "pid": proc.pid,
        "meta_path": str(meta_path),
        "log_path": str(log_path),
        "cmd": cfg["cmd"],
        "cwd": str(cwd),
        "env": cfg["env"],
        "override_env": cfg["override_env"],
        "shell": shell,
        "popen_kwargs": kwargs,
        "create_time": create_time,
        "create_time_human": create_time_human,
    }
    dump_meta(
        meta,
        meta_path,
    )

    print_status(meta)
    return 0


def stop(
    meta_path: PathType,
    timeout=5.0,
):
    meta_path = Path(meta_path).resolve()
    meta = load_meta(meta_path)
    if meta is None:
        print(
            colored(
                "Stop failed: meta file not found (maybe not started)\n",
                color="red",
                attrs=["bold"],
            )
            + str(meta_path),
            file=sys.stderr,
        )
        return 1

    pid = meta["pid"]
    try:
        proc = psutil.Process(pid)
    except psutil.NoSuchProcess:
        print(
            colored(
                f"Process {pid} not found (already exited); removing stale meta file",
                color="yellow",
                attrs=["bold"],
            ),
            file=sys.stderr,
        )
        meta_path.unlink(missing_ok=True)
        print_status(meta)
        return 1

    # check if it's the same process by comparing create_time
    if not check_same_process(proc, meta['create_time']):
        print(
            colored(
                f"Warning: PID {pid} exists but create_time does not match (maybe reused by another process); removing stale meta file",
                color="yellow",
                attrs=["bold"],
            ),
            file=sys.stderr,
        )
        meta_path.unlink(missing_ok=True)
        print_status(meta)
        return 1

    # send SIGTERM first for graceful shutdown (if platform supports)
    proc.terminate()

    # wait for the process to exit or timeout
    try:
        ret = proc.wait(timeout)
        print(
            colored(
                f"Process {pid} exited with code {ret}; removing meta file", color="green", attrs=["bold"]
            ),
            file=sys.stderr,
        )
    except psutil.TimeoutExpired:
        print(
            colored(
                f"Process {pid} did not exit in time; killing it",
                color="yellow",
                attrs=["bold"],
            ),
            file=sys.stderr,
        )

        # first kill child processes
        for child in proc.children(recursive=True):
            try:
                child.kill()
            except Exception:
                pass
        # then kill the parent process
        try:
            proc.kill()
            print(
                colored(f"Killed process {pid}; removing meta file", color="green", attrs=["bold"]),
                file=sys.stderr,
            )
        except Exception as e:
            print(
                colored(
                    f"Failed to kill process {pid}: {e}", color="red", attrs=["bold"]
                ),
                file=sys.stderr,
            )
            print_status(meta)
            return 1

    # remove the PID file
    try:
        # os.remove(pid_file)
        meta_path.unlink(missing_ok=True)
    except OSError:
        pass

    print_status(meta)
    return 0


def restart(
    cfg: DmonCommandConfig,
    timeout=5.0,
):
    stop(cfg["meta_path"], timeout)
    print("--- Restarting ---", file=sys.stderr)
    return start(cfg)


def status(meta_path: PathType):
    meta_path = Path(meta_path).resolve()
    meta = load_meta(meta_path)
    if meta is None:
        print(
            colored(
                "Status failed: meta file not found (maybe not started)\n",
                color="red",
                attrs=["bold"],
            )
            + str(meta_path),
            file=sys.stderr,
        )
        return 1

    print_status(meta)
    return 0


def check_same_process(proc: psutil.Process, create_time: float) -> bool:
    if create_time < 0:
        return False
    return abs(proc.create_time() - create_time) < 1e-3


def check_running(pid: int, create_time: float) -> bool:
    """
    Check if a process with given PID and create_time is running.
    """
    # return psutil.pid_exists(pid)
    if create_time < 0:
        return False
    try:
        p = psutil.Process(pid)
        return abs(p.create_time() - create_time) < 1e-3
    except psutil.NoSuchProcess:
        return False


def print_status(meta: DmonMeta):
    status = (
        colored("Running", on_color="on_green")
        if check_running(meta["pid"], meta["create_time"])
        else colored("Exited", on_color="on_light_red")
    )

    # key-value pairs with aligned keys
    rows = [
        ("NAME", colored(meta["name"], "cyan", attrs=["bold"])),
        ("PID", colored(str(meta["pid"]), "cyan", attrs=["bold"])),
        ("STATUS", status),
        ("CMD", meta["cmd"]),
        ("WORKING DIR", meta["cwd"]),
        ("CREATE TIME", meta["create_time_human"]),
        ("LOG PATH", meta["log_path"]),
        ("META PATH", meta["meta_path"]),
    ]

    # calculate the max width of the keys
    key_width = max(len(key) for key, _ in rows)
    # align the keys and print
    lines = [
        f"{colored(f'{key:<{key_width}}: ', attrs=['dark'])}{value}"
        for key, value in rows
    ]
    print("\n".join(lines), file=sys.stderr)


def list_processes(dir: PathType):
    headers = ("NAME", "PID", "STATUS", "CMD", "CREATE TIME", "LOG PATH")
    metas = []
    target_dmon_dir = Path(dir).resolve()
    if target_dmon_dir.exists() and target_dmon_dir.is_dir():
        for meta_file in target_dmon_dir.glob(f"*{META_SUFFIX}"):
            name = meta_file.stem.rsplit(".", 2)[0]
            meta = load_meta(meta_file)
            if meta is not None:
                status = (
                    colored("Running", on_color="on_green")
                    if check_running(meta["pid"], meta["create_time"])
                    else colored("Exited", on_color="on_light_red")
                )
                metas.append(
                    (
                        colored(name, "cyan", attrs=["bold"]),
                        colored(meta["pid"], "cyan", attrs=["bold"]),
                        status,
                        meta["cmd"],
                        meta["create_time_human"],
                        meta["log_path"],
                    )
                )
    metas.sort()

    lines = []
    lines.append(f"Found {len(metas)} process(es) in {target_dmon_dir}:")

    # insert table header
    metas.insert(0, headers)

    # calculate column widths
    widths = [
        max(len(ANSI_RE.sub("", str(row[i]))) for row in metas)
        for i in range(len(headers))
    ]

    # print the table with proper padding
    for row in metas:
        line = "  ".join(f"{str(cell):<{widths[i]}}" for i, cell in enumerate(row))
        lines.append(line)
    print("\n".join(lines), file=sys.stderr)
    return 0
